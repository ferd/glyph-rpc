done:
    move to wsgi, requests. move to params as constructor; mapper; transient objects; silent server; make_server ssl args; carry over args to werzkeug; form bug; documentation; removed prints; split out into parts; price checker skeleton;
    refactor:
        moved to werkzeug exceptions
        change from Mapper <-> Resources
        to Router <-> Mapper <-> User Objects

    nope: mapper should only take named resources - unnamed ones can be mapped ad-hoc
        rationale: hard to do properly with linking, embedding, etc. 
    done: router should ask resources to urlify themselves?
        mapper now handles this outside router

    worker queue example

    refactoring:
        transientmapper/basemapper - transient mapper handles state transfer
        page/index - split inspection out into different bits.

    ResourceMethod added for safe, inlining
        safe get linked, unsafe get forms, inlines get embed

    after removing index method, use in real world demanded it back
        it's nice - you can now override methods
        that broke though as it got passed back in

    renaming done
    query args now encoded too - because it's nice not to have to cast.

    @glyph.redirect()
        a decorator, makes the function do the redirect from return value

    glyph.form(Resource) should work 
        methodargs for class 
        POST to a Resouce.index should redirect to the instance
        glyph.get(url/link/page?, options) etc?
            glyph.url(object) returns the url as a string

    moved stuff around, added docstrings
    moved parsing handling into mapper & resourcemethod
    creating objects different from lookup
    persistent mapping proof of concept
    index creation moved to resourcemethod (noice!)
    throw correct http exceptions, remove bare excepts
    resourcemethod takes another as constructor
    using werkzeug.utils.redirect(location, code=302)
    optional requests dependency
    reject dupe keys

remember:
    should handle http mapping by default, verbs, urls and content_type
    should be possible to use objects outside of mapper.
    http ignorant not agnostic (don't need to know http semantics to use it, but can override)

todo documentation:
        under the scenes - request by request
            worked repl example
        glyph encoding clarifcations/iana-esque spec
            duplicate dict keys,hex parsing
        tutorial
            build a server, use a client
            add methods

        node/extension data types
        cookbook more examples:doing it by hand client/server.
        examples/pricechecker/ add loadbalancers, test caching, sharding version too

        explain: is it rest?
            put vs post essentially - hypermedia forms vs resources with verbs
            yes - hyperlinks, hateoas, caching
            no - non standard mime type, ad-hoc interfaces 

todo code
    re-import glyph rpc
    move to wsgi internally :v
    encoding:
        split out nodes/extensions from base

    glyph encoding/ media types:
        resource handles/parses accept/content-type header
        must be able to dispatch to correct method?

        glyphmethod.call(....)
        http headers:
            parsing content-type?
            date, cache-control, etc
        glyph.get/fetch supports other media types

        return xml or json instead of glyph
            @accept(), @content_type()
            extend resourcemthod to override post/get

    mapper:
        transients - shouldn't post to create?
        or form method is get for transient objects
            default method on glyphmapper

        with no default, just links to functions/object creators
        handling functions ? 
            defaulty a post mapper ?
            overriding with resourcemethod?
            mapper should only call self, router and resourcemethod.*
                ensures delegation etc.
            mapper should only map to latter part of url ?

    glyph json/xhtml:
        write data types.
            should add/draft them
                make a spec, get the vendor tag registered
            rules for forms, embeds?
        new data types: charset handling ? timezones? time periods ?
            resource type (like link,etc has a href, but is default page container)o
        form elements should have some type info perhaps ?
            i.e akin to input = ... 


        format changes:
            [] {} U<len>: l<arbitrary>

        application/vnd.glyph+json vnd.glyph+xml
            map glyph types to xhtml/json
                {'__glyph': embedded object } 
            escape sequence:
                {'__glyph__foo' : object } -> mapped to {'__glyphfoo'}
                    so __glyph becomes __glyph__, __glyph__ becomes, ___glyph____
            serializing! lxml!
        xml:
            xhtml: use a glyph namespace to annotate links/objects
                glyph:type"link"? 
            or write an xml format and include xslt transformation
                possibly better and simpler.
                can also add script to reformat requests ? 
                or x-www-urlencoding/form encoding?
        in-browser control/debugging:
            danger: cross site request forgery?

    refactor?
        glyph.rpc, glyph.encoding  - __init__ ties it together / dep inj
        glyph.tests.encoding, rpc

        setup.py test target 

        glyph.client, server, model, encoding
            encoding uses dep injection.
            model has constructors, link etc ?



    decorators chains:
        rel attribute on methods? 
        @glyph.method(rel='....')
        def foo()
            ....

        @foo.accept()
        @foo.if_none_match() .... ?
        @foo.last_modified()

        @glyph.cache(max_age=....)
        resource last modified property ?

        cache control - max age, can store, revalidate?
            caching on embeds?

    api:
        persistent mapper: managing objects/deleting them

        glyph.get(url, accept='....') handling different content-types 
            url in page object?
            if unhandledd:
                throw result(content_type, content), decoded if text/*

        handle: return [Resource(), ....]
            callback from router turns resources into links/forms/etc?
            possible: handles unknown types with callback

        refactoring: make it dict driven instead of if-chain driven?


        decorators? ssl only, idempotent (nope cos put etc break)?

        collections:
            like an embed/property, but behaves with the __getitem__ calls ?
            think about interface for pagination/mapping to an infinite scroll, etc.
            inlining - behaves like a link, isn't.
            cursor/resultset behavior?

    snapshoting:
        crawling an api? glyph.crawl(page) returns all links() ?

    api versioning?
        possibly: map default to /v0/ , default takes a version arg? breaks url mapping :v
        possibly: / returns 300 if multiple versions, link header? rel=...

    @property ?
        should index them ? hard to link - link with extra methods?

    properties of resources:
        things that apply to resources, but are not serialized as the state
        e.g timestamps, versions
        want to be able to say @glyph.version()/if not modified, etc
        on forms, etc?

    transactions?
        preconditions/postconditions on forms

    demos:
        heroku/appengine ?
        examples for a talk?
        atom pub mail server?  mail store? forum queue/broker(herp?)
            use preconditions to do transactional semantics?
        tekpub/ 
            http://wekeroad.com/2012/03/03/moving-the-philosophy-into-machinery/

    scraper pool ?
        sharding, load balancing, caching, extending

misc shit:
    snmp? crawling
    twitter api - last-modified embedding hack
            use embedded for all new items, links for all client is expected to have already
    db cursors alike for collections ? pagination

    jquery plugin?
    ruby, js - object style
    cgi/php: create foo.php for each resource, use links.
    0mq transport :v websocket upgrades to get a bi-di socket :v
    routing: use werkzeug rules inside router
        nope - does arg parsing
